// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: passport.proto

/*
	Package evntsrc_passport is a generated protocol buffer package.

	It is generated from these files:
		passport.proto

	It has these top-level messages:
		Timestamp
		Tokens
		VerifyTokenRequest
		VerifyTokenResponse
		UserCreds
		OAuthClientSecretCreds
		OAuthCodeCreds
		AuthRequest
		AuthResponse
		MFAResponse
		RefreshRequest
		SocialRequest
		Revoke
		Empty
*/
package evntsrc_passport

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/gogo/googleapis/google/api"

import context "golang.org/x/net/context"
import grpc "google.golang.org/grpc"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Timestamp struct {
	Seconds int64 `protobuf:"varint,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
	Nanos   int32 `protobuf:"varint,2,opt,name=nanos,proto3" json:"nanos,omitempty"`
}

func (m *Timestamp) Reset()                    { *m = Timestamp{} }
func (m *Timestamp) String() string            { return proto.CompactTextString(m) }
func (*Timestamp) ProtoMessage()               {}
func (*Timestamp) Descriptor() ([]byte, []int) { return fileDescriptorPassport, []int{0} }

func (m *Timestamp) GetSeconds() int64 {
	if m != nil {
		return m.Seconds
	}
	return 0
}

func (m *Timestamp) GetNanos() int32 {
	if m != nil {
		return m.Nanos
	}
	return 0
}

func (*Timestamp) XXX_MessageName() string {
	return "evntsrc.passport.Timestamp"
}

type Tokens struct {
	Token         string     `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	TokenExpire   *Timestamp `protobuf:"bytes,2,opt,name=tokenExpire" json:"tokenExpire,omitempty"`
	RefreshToken  string     `protobuf:"bytes,3,opt,name=refreshToken,proto3" json:"refreshToken,omitempty"`
	RefreshExpire *Timestamp `protobuf:"bytes,4,opt,name=refreshExpire" json:"refreshExpire,omitempty"`
}

func (m *Tokens) Reset()                    { *m = Tokens{} }
func (m *Tokens) String() string            { return proto.CompactTextString(m) }
func (*Tokens) ProtoMessage()               {}
func (*Tokens) Descriptor() ([]byte, []int) { return fileDescriptorPassport, []int{1} }

func (m *Tokens) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *Tokens) GetTokenExpire() *Timestamp {
	if m != nil {
		return m.TokenExpire
	}
	return nil
}

func (m *Tokens) GetRefreshToken() string {
	if m != nil {
		return m.RefreshToken
	}
	return ""
}

func (m *Tokens) GetRefreshExpire() *Timestamp {
	if m != nil {
		return m.RefreshExpire
	}
	return nil
}

func (*Tokens) XXX_MessageName() string {
	return "evntsrc.passport.Tokens"
}

type VerifyTokenRequest struct {
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *VerifyTokenRequest) Reset()                    { *m = VerifyTokenRequest{} }
func (m *VerifyTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*VerifyTokenRequest) ProtoMessage()               {}
func (*VerifyTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptorPassport, []int{2} }

func (m *VerifyTokenRequest) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (*VerifyTokenRequest) XXX_MessageName() string {
	return "evntsrc.passport.VerifyTokenRequest"
}

type VerifyTokenResponse struct {
	Valid         bool       `protobuf:"varint,1,opt,name=valid,proto3" json:"valid,omitempty"`
	Revoked       bool       `protobuf:"varint,2,opt,name=revoked,proto3" json:"revoked,omitempty"`
	TokenExpire   *Timestamp `protobuf:"bytes,3,opt,name=tokenExpire" json:"tokenExpire,omitempty"`
	RefreshExpire *Timestamp `protobuf:"bytes,4,opt,name=refreshExpire" json:"refreshExpire,omitempty"`
}

func (m *VerifyTokenResponse) Reset()                    { *m = VerifyTokenResponse{} }
func (m *VerifyTokenResponse) String() string            { return proto.CompactTextString(m) }
func (*VerifyTokenResponse) ProtoMessage()               {}
func (*VerifyTokenResponse) Descriptor() ([]byte, []int) { return fileDescriptorPassport, []int{3} }

func (m *VerifyTokenResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *VerifyTokenResponse) GetRevoked() bool {
	if m != nil {
		return m.Revoked
	}
	return false
}

func (m *VerifyTokenResponse) GetTokenExpire() *Timestamp {
	if m != nil {
		return m.TokenExpire
	}
	return nil
}

func (m *VerifyTokenResponse) GetRefreshExpire() *Timestamp {
	if m != nil {
		return m.RefreshExpire
	}
	return nil
}

func (*VerifyTokenResponse) XXX_MessageName() string {
	return "evntsrc.passport.VerifyTokenResponse"
}

type UserCreds struct {
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	MFA      string `protobuf:"bytes,3,opt,name=MFA,proto3" json:"MFA,omitempty"`
}

func (m *UserCreds) Reset()                    { *m = UserCreds{} }
func (m *UserCreds) String() string            { return proto.CompactTextString(m) }
func (*UserCreds) ProtoMessage()               {}
func (*UserCreds) Descriptor() ([]byte, []int) { return fileDescriptorPassport, []int{4} }

func (m *UserCreds) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *UserCreds) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *UserCreds) GetMFA() string {
	if m != nil {
		return m.MFA
	}
	return ""
}

func (*UserCreds) XXX_MessageName() string {
	return "evntsrc.passport.UserCreds"
}

type OAuthClientSecretCreds struct {
	Key    string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Secret string   `protobuf:"bytes,2,opt,name=secret,proto3" json:"secret,omitempty"`
	Scopes []string `protobuf:"bytes,3,rep,name=scopes" json:"scopes,omitempty"`
}

func (m *OAuthClientSecretCreds) Reset()                    { *m = OAuthClientSecretCreds{} }
func (m *OAuthClientSecretCreds) String() string            { return proto.CompactTextString(m) }
func (*OAuthClientSecretCreds) ProtoMessage()               {}
func (*OAuthClientSecretCreds) Descriptor() ([]byte, []int) { return fileDescriptorPassport, []int{5} }

func (m *OAuthClientSecretCreds) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *OAuthClientSecretCreds) GetSecret() string {
	if m != nil {
		return m.Secret
	}
	return ""
}

func (m *OAuthClientSecretCreds) GetScopes() []string {
	if m != nil {
		return m.Scopes
	}
	return nil
}

func (*OAuthClientSecretCreds) XXX_MessageName() string {
	return "evntsrc.passport.OAuthClientSecretCreds"
}

type OAuthCodeCreds struct {
	Code string `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *OAuthCodeCreds) Reset()                    { *m = OAuthCodeCreds{} }
func (m *OAuthCodeCreds) String() string            { return proto.CompactTextString(m) }
func (*OAuthCodeCreds) ProtoMessage()               {}
func (*OAuthCodeCreds) Descriptor() ([]byte, []int) { return fileDescriptorPassport, []int{6} }

func (m *OAuthCodeCreds) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (*OAuthCodeCreds) XXX_MessageName() string {
	return "evntsrc.passport.OAuthCodeCreds"
}

type AuthRequest struct {
	// Types that are valid to be assigned to Creds:
	//	*AuthRequest_UserCreds
	//	*AuthRequest_OauthClientSecretCreds
	//	*AuthRequest_OAuthCodeCreds
	Creds isAuthRequest_Creds `protobuf_oneof:"creds"`
}

func (m *AuthRequest) Reset()                    { *m = AuthRequest{} }
func (m *AuthRequest) String() string            { return proto.CompactTextString(m) }
func (*AuthRequest) ProtoMessage()               {}
func (*AuthRequest) Descriptor() ([]byte, []int) { return fileDescriptorPassport, []int{7} }

type isAuthRequest_Creds interface {
	isAuthRequest_Creds()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AuthRequest_UserCreds struct {
	UserCreds *UserCreds `protobuf:"bytes,1,opt,name=userCreds,oneof"`
}
type AuthRequest_OauthClientSecretCreds struct {
	OauthClientSecretCreds *OAuthClientSecretCreds `protobuf:"bytes,2,opt,name=oauthClientSecretCreds,oneof"`
}
type AuthRequest_OAuthCodeCreds struct {
	OAuthCodeCreds *OAuthCodeCreds `protobuf:"bytes,3,opt,name=OAuthCodeCreds,oneof"`
}

func (*AuthRequest_UserCreds) isAuthRequest_Creds()              {}
func (*AuthRequest_OauthClientSecretCreds) isAuthRequest_Creds() {}
func (*AuthRequest_OAuthCodeCreds) isAuthRequest_Creds()         {}

func (m *AuthRequest) GetCreds() isAuthRequest_Creds {
	if m != nil {
		return m.Creds
	}
	return nil
}

func (m *AuthRequest) GetUserCreds() *UserCreds {
	if x, ok := m.GetCreds().(*AuthRequest_UserCreds); ok {
		return x.UserCreds
	}
	return nil
}

func (m *AuthRequest) GetOauthClientSecretCreds() *OAuthClientSecretCreds {
	if x, ok := m.GetCreds().(*AuthRequest_OauthClientSecretCreds); ok {
		return x.OauthClientSecretCreds
	}
	return nil
}

func (m *AuthRequest) GetOAuthCodeCreds() *OAuthCodeCreds {
	if x, ok := m.GetCreds().(*AuthRequest_OAuthCodeCreds); ok {
		return x.OAuthCodeCreds
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AuthRequest) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AuthRequest_OneofMarshaler, _AuthRequest_OneofUnmarshaler, _AuthRequest_OneofSizer, []interface{}{
		(*AuthRequest_UserCreds)(nil),
		(*AuthRequest_OauthClientSecretCreds)(nil),
		(*AuthRequest_OAuthCodeCreds)(nil),
	}
}

func _AuthRequest_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AuthRequest)
	// creds
	switch x := m.Creds.(type) {
	case *AuthRequest_UserCreds:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.UserCreds); err != nil {
			return err
		}
	case *AuthRequest_OauthClientSecretCreds:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OauthClientSecretCreds); err != nil {
			return err
		}
	case *AuthRequest_OAuthCodeCreds:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OAuthCodeCreds); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AuthRequest.Creds has unexpected type %T", x)
	}
	return nil
}

func _AuthRequest_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AuthRequest)
	switch tag {
	case 1: // creds.userCreds
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UserCreds)
		err := b.DecodeMessage(msg)
		m.Creds = &AuthRequest_UserCreds{msg}
		return true, err
	case 2: // creds.oauthClientSecretCreds
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OAuthClientSecretCreds)
		err := b.DecodeMessage(msg)
		m.Creds = &AuthRequest_OauthClientSecretCreds{msg}
		return true, err
	case 3: // creds.OAuthCodeCreds
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OAuthCodeCreds)
		err := b.DecodeMessage(msg)
		m.Creds = &AuthRequest_OAuthCodeCreds{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AuthRequest_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AuthRequest)
	// creds
	switch x := m.Creds.(type) {
	case *AuthRequest_UserCreds:
		s := proto.Size(x.UserCreds)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AuthRequest_OauthClientSecretCreds:
		s := proto.Size(x.OauthClientSecretCreds)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AuthRequest_OAuthCodeCreds:
		s := proto.Size(x.OAuthCodeCreds)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func (*AuthRequest) XXX_MessageName() string {
	return "evntsrc.passport.AuthRequest"
}

type AuthResponse struct {
	Success     bool         `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Tokens      *Tokens      `protobuf:"bytes,2,opt,name=tokens" json:"tokens,omitempty"`
	MFAResponse *MFAResponse `protobuf:"bytes,3,opt,name=MFAResponse" json:"MFAResponse,omitempty"`
}

func (m *AuthResponse) Reset()                    { *m = AuthResponse{} }
func (m *AuthResponse) String() string            { return proto.CompactTextString(m) }
func (*AuthResponse) ProtoMessage()               {}
func (*AuthResponse) Descriptor() ([]byte, []int) { return fileDescriptorPassport, []int{8} }

func (m *AuthResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *AuthResponse) GetTokens() *Tokens {
	if m != nil {
		return m.Tokens
	}
	return nil
}

func (m *AuthResponse) GetMFAResponse() *MFAResponse {
	if m != nil {
		return m.MFAResponse
	}
	return nil
}

func (*AuthResponse) XXX_MessageName() string {
	return "evntsrc.passport.AuthResponse"
}

type MFAResponse struct {
	Type      string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Challenge string `protobuf:"bytes,2,opt,name=challenge,proto3" json:"challenge,omitempty"`
}

func (m *MFAResponse) Reset()                    { *m = MFAResponse{} }
func (m *MFAResponse) String() string            { return proto.CompactTextString(m) }
func (*MFAResponse) ProtoMessage()               {}
func (*MFAResponse) Descriptor() ([]byte, []int) { return fileDescriptorPassport, []int{9} }

func (m *MFAResponse) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *MFAResponse) GetChallenge() string {
	if m != nil {
		return m.Challenge
	}
	return ""
}

func (*MFAResponse) XXX_MessageName() string {
	return "evntsrc.passport.MFAResponse"
}

type RefreshRequest struct {
	RefreshToken string `protobuf:"bytes,1,opt,name=refreshToken,proto3" json:"refreshToken,omitempty"`
}

func (m *RefreshRequest) Reset()                    { *m = RefreshRequest{} }
func (m *RefreshRequest) String() string            { return proto.CompactTextString(m) }
func (*RefreshRequest) ProtoMessage()               {}
func (*RefreshRequest) Descriptor() ([]byte, []int) { return fileDescriptorPassport, []int{10} }

func (m *RefreshRequest) GetRefreshToken() string {
	if m != nil {
		return m.RefreshToken
	}
	return ""
}

func (*RefreshRequest) XXX_MessageName() string {
	return "evntsrc.passport.RefreshRequest"
}

type SocialRequest struct {
	Provider  string  `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
	IdpTokens *Tokens `protobuf:"bytes,2,opt,name=idpTokens" json:"idpTokens,omitempty"`
}

func (m *SocialRequest) Reset()                    { *m = SocialRequest{} }
func (m *SocialRequest) String() string            { return proto.CompactTextString(m) }
func (*SocialRequest) ProtoMessage()               {}
func (*SocialRequest) Descriptor() ([]byte, []int) { return fileDescriptorPassport, []int{11} }

func (m *SocialRequest) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *SocialRequest) GetIdpTokens() *Tokens {
	if m != nil {
		return m.IdpTokens
	}
	return nil
}

func (*SocialRequest) XXX_MessageName() string {
	return "evntsrc.passport.SocialRequest"
}

type Revoke struct {
	Id     string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty" bson:"_id"`
	Jti    string `protobuf:"bytes,2,opt,name=jti,proto3" json:"jti,omitempty"`
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *Revoke) Reset()                    { *m = Revoke{} }
func (m *Revoke) String() string            { return proto.CompactTextString(m) }
func (*Revoke) ProtoMessage()               {}
func (*Revoke) Descriptor() ([]byte, []int) { return fileDescriptorPassport, []int{12} }

func (m *Revoke) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Revoke) GetJti() string {
	if m != nil {
		return m.Jti
	}
	return ""
}

func (m *Revoke) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (*Revoke) XXX_MessageName() string {
	return "evntsrc.passport.Revoke"
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptorPassport, []int{13} }

func (*Empty) XXX_MessageName() string {
	return "evntsrc.passport.Empty"
}
func init() {
	proto.RegisterType((*Timestamp)(nil), "evntsrc.passport.Timestamp")
	proto.RegisterType((*Tokens)(nil), "evntsrc.passport.Tokens")
	proto.RegisterType((*VerifyTokenRequest)(nil), "evntsrc.passport.VerifyTokenRequest")
	proto.RegisterType((*VerifyTokenResponse)(nil), "evntsrc.passport.VerifyTokenResponse")
	proto.RegisterType((*UserCreds)(nil), "evntsrc.passport.UserCreds")
	proto.RegisterType((*OAuthClientSecretCreds)(nil), "evntsrc.passport.OAuthClientSecretCreds")
	proto.RegisterType((*OAuthCodeCreds)(nil), "evntsrc.passport.OAuthCodeCreds")
	proto.RegisterType((*AuthRequest)(nil), "evntsrc.passport.AuthRequest")
	proto.RegisterType((*AuthResponse)(nil), "evntsrc.passport.AuthResponse")
	proto.RegisterType((*MFAResponse)(nil), "evntsrc.passport.MFAResponse")
	proto.RegisterType((*RefreshRequest)(nil), "evntsrc.passport.RefreshRequest")
	proto.RegisterType((*SocialRequest)(nil), "evntsrc.passport.SocialRequest")
	proto.RegisterType((*Revoke)(nil), "evntsrc.passport.Revoke")
	proto.RegisterType((*Empty)(nil), "evntsrc.passport.Empty")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AuthSevice service

type AuthSeviceClient interface {
	VerifyToken(ctx context.Context, in *VerifyTokenRequest, opts ...grpc.CallOption) (*VerifyTokenResponse, error)
	Authenticate(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	Refresh(ctx context.Context, in *RefreshRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	SocialLogin(ctx context.Context, in *SocialRequest, opts ...grpc.CallOption) (*AuthResponse, error)
	RevokeToken(ctx context.Context, in *Revoke, opts ...grpc.CallOption) (*Empty, error)
}

type authSeviceClient struct {
	cc *grpc.ClientConn
}

func NewAuthSeviceClient(cc *grpc.ClientConn) AuthSeviceClient {
	return &authSeviceClient{cc}
}

func (c *authSeviceClient) VerifyToken(ctx context.Context, in *VerifyTokenRequest, opts ...grpc.CallOption) (*VerifyTokenResponse, error) {
	out := new(VerifyTokenResponse)
	err := grpc.Invoke(ctx, "/evntsrc.passport.AuthSevice/verifyToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authSeviceClient) Authenticate(ctx context.Context, in *AuthRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	out := new(AuthResponse)
	err := grpc.Invoke(ctx, "/evntsrc.passport.AuthSevice/authenticate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authSeviceClient) Refresh(ctx context.Context, in *RefreshRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	out := new(AuthResponse)
	err := grpc.Invoke(ctx, "/evntsrc.passport.AuthSevice/refresh", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authSeviceClient) SocialLogin(ctx context.Context, in *SocialRequest, opts ...grpc.CallOption) (*AuthResponse, error) {
	out := new(AuthResponse)
	err := grpc.Invoke(ctx, "/evntsrc.passport.AuthSevice/socialLogin", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authSeviceClient) RevokeToken(ctx context.Context, in *Revoke, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/evntsrc.passport.AuthSevice/revokeToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AuthSevice service

type AuthSeviceServer interface {
	VerifyToken(context.Context, *VerifyTokenRequest) (*VerifyTokenResponse, error)
	Authenticate(context.Context, *AuthRequest) (*AuthResponse, error)
	Refresh(context.Context, *RefreshRequest) (*AuthResponse, error)
	SocialLogin(context.Context, *SocialRequest) (*AuthResponse, error)
	RevokeToken(context.Context, *Revoke) (*Empty, error)
}

func RegisterAuthSeviceServer(s *grpc.Server, srv AuthSeviceServer) {
	s.RegisterService(&_AuthSevice_serviceDesc, srv)
}

func _AuthSevice_VerifyToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthSeviceServer).VerifyToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/evntsrc.passport.AuthSevice/VerifyToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthSeviceServer).VerifyToken(ctx, req.(*VerifyTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthSevice_Authenticate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthSeviceServer).Authenticate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/evntsrc.passport.AuthSevice/Authenticate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthSeviceServer).Authenticate(ctx, req.(*AuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthSevice_Refresh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthSeviceServer).Refresh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/evntsrc.passport.AuthSevice/Refresh",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthSeviceServer).Refresh(ctx, req.(*RefreshRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthSevice_SocialLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SocialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthSeviceServer).SocialLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/evntsrc.passport.AuthSevice/SocialLogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthSeviceServer).SocialLogin(ctx, req.(*SocialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AuthSevice_RevokeToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Revoke)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AuthSeviceServer).RevokeToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/evntsrc.passport.AuthSevice/RevokeToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AuthSeviceServer).RevokeToken(ctx, req.(*Revoke))
	}
	return interceptor(ctx, in, info, handler)
}

var _AuthSevice_serviceDesc = grpc.ServiceDesc{
	ServiceName: "evntsrc.passport.AuthSevice",
	HandlerType: (*AuthSeviceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "verifyToken",
			Handler:    _AuthSevice_VerifyToken_Handler,
		},
		{
			MethodName: "authenticate",
			Handler:    _AuthSevice_Authenticate_Handler,
		},
		{
			MethodName: "refresh",
			Handler:    _AuthSevice_Refresh_Handler,
		},
		{
			MethodName: "socialLogin",
			Handler:    _AuthSevice_SocialLogin_Handler,
		},
		{
			MethodName: "revokeToken",
			Handler:    _AuthSevice_RevokeToken_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "passport.proto",
}

func (m *Timestamp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Timestamp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seconds != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPassport(dAtA, i, uint64(m.Seconds))
	}
	if m.Nanos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPassport(dAtA, i, uint64(m.Nanos))
	}
	return i, nil
}

func (m *Tokens) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tokens) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	if m.TokenExpire != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPassport(dAtA, i, uint64(m.TokenExpire.Size()))
		n1, err := m.TokenExpire.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.RefreshToken) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPassport(dAtA, i, uint64(len(m.RefreshToken)))
		i += copy(dAtA[i:], m.RefreshToken)
	}
	if m.RefreshExpire != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPassport(dAtA, i, uint64(m.RefreshExpire.Size()))
		n2, err := m.RefreshExpire.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *VerifyTokenRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyTokenRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Token)))
		i += copy(dAtA[i:], m.Token)
	}
	return i, nil
}

func (m *VerifyTokenResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyTokenResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Valid {
		dAtA[i] = 0x8
		i++
		if m.Valid {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Revoked {
		dAtA[i] = 0x10
		i++
		if m.Revoked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.TokenExpire != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPassport(dAtA, i, uint64(m.TokenExpire.Size()))
		n3, err := m.TokenExpire.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.RefreshExpire != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintPassport(dAtA, i, uint64(m.RefreshExpire.Size()))
		n4, err := m.RefreshExpire.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *UserCreds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserCreds) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if len(m.MFA) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPassport(dAtA, i, uint64(len(m.MFA)))
		i += copy(dAtA[i:], m.MFA)
	}
	return i, nil
}

func (m *OAuthClientSecretCreds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OAuthClientSecretCreds) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Secret) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Secret)))
		i += copy(dAtA[i:], m.Secret)
	}
	if len(m.Scopes) > 0 {
		for _, s := range m.Scopes {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *OAuthCodeCreds) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OAuthCodeCreds) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Code) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Code)))
		i += copy(dAtA[i:], m.Code)
	}
	return i, nil
}

func (m *AuthRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Creds != nil {
		nn5, err := m.Creds.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn5
	}
	return i, nil
}

func (m *AuthRequest_UserCreds) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.UserCreds != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPassport(dAtA, i, uint64(m.UserCreds.Size()))
		n6, err := m.UserCreds.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}
func (m *AuthRequest_OauthClientSecretCreds) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OauthClientSecretCreds != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPassport(dAtA, i, uint64(m.OauthClientSecretCreds.Size()))
		n7, err := m.OauthClientSecretCreds.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}
func (m *AuthRequest_OAuthCodeCreds) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.OAuthCodeCreds != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPassport(dAtA, i, uint64(m.OAuthCodeCreds.Size()))
		n8, err := m.OAuthCodeCreds.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}
func (m *AuthResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Tokens != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPassport(dAtA, i, uint64(m.Tokens.Size()))
		n9, err := m.Tokens.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.MFAResponse != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPassport(dAtA, i, uint64(m.MFAResponse.Size()))
		n10, err := m.MFAResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *MFAResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MFAResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Type)))
		i += copy(dAtA[i:], m.Type)
	}
	if len(m.Challenge) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Challenge)))
		i += copy(dAtA[i:], m.Challenge)
	}
	return i, nil
}

func (m *RefreshRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RefreshToken) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPassport(dAtA, i, uint64(len(m.RefreshToken)))
		i += copy(dAtA[i:], m.RefreshToken)
	}
	return i, nil
}

func (m *SocialRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SocialRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Provider) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Provider)))
		i += copy(dAtA[i:], m.Provider)
	}
	if m.IdpTokens != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPassport(dAtA, i, uint64(m.IdpTokens.Size()))
		n11, err := m.IdpTokens.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *Revoke) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Revoke) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.Jti) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Jti)))
		i += copy(dAtA[i:], m.Jti)
	}
	if len(m.Reason) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Reason)))
		i += copy(dAtA[i:], m.Reason)
	}
	return i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintPassport(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Timestamp) Size() (n int) {
	var l int
	_ = l
	if m.Seconds != 0 {
		n += 1 + sovPassport(uint64(m.Seconds))
	}
	if m.Nanos != 0 {
		n += 1 + sovPassport(uint64(m.Nanos))
	}
	return n
}

func (m *Tokens) Size() (n int) {
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	if m.TokenExpire != nil {
		l = m.TokenExpire.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.RefreshToken)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	if m.RefreshExpire != nil {
		l = m.RefreshExpire.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *VerifyTokenRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *VerifyTokenResponse) Size() (n int) {
	var l int
	_ = l
	if m.Valid {
		n += 2
	}
	if m.Revoked {
		n += 2
	}
	if m.TokenExpire != nil {
		l = m.TokenExpire.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	if m.RefreshExpire != nil {
		l = m.RefreshExpire.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *UserCreds) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.MFA)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *OAuthClientSecretCreds) Size() (n int) {
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	if len(m.Scopes) > 0 {
		for _, s := range m.Scopes {
			l = len(s)
			n += 1 + l + sovPassport(uint64(l))
		}
	}
	return n
}

func (m *OAuthCodeCreds) Size() (n int) {
	var l int
	_ = l
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *AuthRequest) Size() (n int) {
	var l int
	_ = l
	if m.Creds != nil {
		n += m.Creds.Size()
	}
	return n
}

func (m *AuthRequest_UserCreds) Size() (n int) {
	var l int
	_ = l
	if m.UserCreds != nil {
		l = m.UserCreds.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}
func (m *AuthRequest_OauthClientSecretCreds) Size() (n int) {
	var l int
	_ = l
	if m.OauthClientSecretCreds != nil {
		l = m.OauthClientSecretCreds.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}
func (m *AuthRequest_OAuthCodeCreds) Size() (n int) {
	var l int
	_ = l
	if m.OAuthCodeCreds != nil {
		l = m.OAuthCodeCreds.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}
func (m *AuthResponse) Size() (n int) {
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.Tokens != nil {
		l = m.Tokens.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	if m.MFAResponse != nil {
		l = m.MFAResponse.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *MFAResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.Challenge)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *RefreshRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.RefreshToken)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *SocialRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	if m.IdpTokens != nil {
		l = m.IdpTokens.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *Revoke) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.Jti)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *Empty) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovPassport(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPassport(x uint64) (n int) {
	return sovPassport(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Timestamp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seconds", wireType)
			}
			m.Seconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seconds |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nanos", wireType)
			}
			m.Nanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nanos |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tokens) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tokens: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tokens: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenExpire", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TokenExpire == nil {
				m.TokenExpire = &Timestamp{}
			}
			if err := m.TokenExpire.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshExpire", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RefreshExpire == nil {
				m.RefreshExpire = &Timestamp{}
			}
			if err := m.RefreshExpire.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyTokenRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyTokenRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyTokenRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyTokenResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyTokenResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyTokenResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Valid", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Valid = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revoked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Revoked = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenExpire", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TokenExpire == nil {
				m.TokenExpire = &Timestamp{}
			}
			if err := m.TokenExpire.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshExpire", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RefreshExpire == nil {
				m.RefreshExpire = &Timestamp{}
			}
			if err := m.RefreshExpire.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserCreds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserCreds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserCreds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFA", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MFA = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OAuthClientSecretCreds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OAuthClientSecretCreds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OAuthClientSecretCreds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scopes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scopes = append(m.Scopes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OAuthCodeCreds) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OAuthCodeCreds: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OAuthCodeCreds: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserCreds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UserCreds{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Creds = &AuthRequest_UserCreds{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OauthClientSecretCreds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OAuthClientSecretCreds{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Creds = &AuthRequest_OauthClientSecretCreds{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OAuthCodeCreds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &OAuthCodeCreds{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Creds = &AuthRequest_OAuthCodeCreds{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Tokens == nil {
				m.Tokens = &Tokens{}
			}
			if err := m.Tokens.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MFAResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MFAResponse == nil {
				m.MFAResponse = &MFAResponse{}
			}
			if err := m.MFAResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MFAResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MFAResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MFAResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Challenge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SocialRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SocialRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SocialRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdpTokens", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdpTokens == nil {
				m.IdpTokens = &Tokens{}
			}
			if err := m.IdpTokens.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Revoke) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Revoke: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Revoke: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPassport(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPassport
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPassport
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPassport(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPassport = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPassport   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("passport.proto", fileDescriptorPassport) }

var fileDescriptorPassport = []byte{
	// 866 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0x5f, 0x6b, 0x23, 0x55,
	0x14, 0xcf, 0x24, 0x69, 0xda, 0x9c, 0x74, 0x63, 0xb9, 0xbb, 0xd4, 0x18, 0x35, 0x5b, 0x2e, 0x2b,
	0x94, 0x82, 0x89, 0xee, 0x8a, 0x42, 0x17, 0x91, 0x76, 0xd9, 0xa5, 0x2c, 0x16, 0xe1, 0xb6, 0xeb,
	0x83, 0x08, 0x32, 0x99, 0x39, 0x4d, 0xee, 0x36, 0x99, 0x3b, 0xde, 0x7b, 0x33, 0xda, 0x57, 0x5f,
	0xc4, 0x67, 0x5f, 0x04, 0xbf, 0x8c, 0x0f, 0x82, 0x7d, 0x14, 0x7c, 0x17, 0x69, 0xfd, 0x04, 0x7e,
	0x02, 0xb9, 0x7f, 0x26, 0x6d, 0x32, 0x53, 0xaa, 0xb0, 0x6f, 0xe7, 0xdc, 0xf9, 0x9d, 0xdf, 0xb9,
	0xe7, 0x9c, 0xdf, 0x3d, 0x03, 0xed, 0x34, 0x54, 0x2a, 0x15, 0x52, 0xf7, 0x53, 0x29, 0xb4, 0x20,
	0x1b, 0x98, 0x25, 0x5a, 0xc9, 0xa8, 0x9f, 0x9f, 0x77, 0xdf, 0x1d, 0x71, 0x3d, 0x9e, 0x0d, 0xfb,
	0x91, 0x98, 0x0e, 0x46, 0x62, 0x24, 0x06, 0x16, 0x38, 0x9c, 0x9d, 0x58, 0xcf, 0x3a, 0xd6, 0x72,
	0x04, 0xdd, 0x8f, 0x96, 0xe1, 0x23, 0x21, 0x46, 0x13, 0x0c, 0x53, 0xae, 0xbc, 0x39, 0x08, 0x53,
	0x3e, 0x08, 0x93, 0x44, 0xe8, 0x50, 0x73, 0x91, 0x28, 0x17, 0x48, 0x1f, 0x43, 0xf3, 0x98, 0x4f,
	0x51, 0xe9, 0x70, 0x9a, 0x92, 0x0e, 0xac, 0x2a, 0x8c, 0x44, 0x12, 0xab, 0x4e, 0xb0, 0x15, 0x6c,
	0xd7, 0x58, 0xee, 0x92, 0x7b, 0xb0, 0x92, 0x84, 0x89, 0x50, 0x9d, 0xea, 0x56, 0xb0, 0xbd, 0xc2,
	0x9c, 0x43, 0x7f, 0x0d, 0xa0, 0x71, 0x2c, 0x4e, 0x31, 0xb1, 0x00, 0x6d, 0x2c, 0x1b, 0xd8, 0x64,
	0xce, 0x21, 0x1f, 0x43, 0xcb, 0x1a, 0x4f, 0xbf, 0x4d, 0xb9, 0x44, 0x1b, 0xdc, 0x7a, 0xf8, 0x66,
	0x7f, 0xb9, 0xda, 0xfe, 0xfc, 0x0a, 0xec, 0x3a, 0x9e, 0x50, 0x58, 0x97, 0x78, 0x22, 0x51, 0x8d,
	0x6d, 0x96, 0x4e, 0xcd, 0x72, 0x2f, 0x9c, 0x91, 0x3d, 0xb8, 0xe3, 0x7d, 0x9f, 0xa4, 0x7e, 0x7b,
	0x92, 0xc5, 0x08, 0xba, 0x03, 0xe4, 0x73, 0x94, 0xfc, 0xe4, 0xcc, 0x32, 0x32, 0xfc, 0x7a, 0x86,
	0x4a, 0x97, 0x57, 0x44, 0x7f, 0x0b, 0xe0, 0xee, 0x02, 0x58, 0xa5, 0x22, 0x51, 0x68, 0xd0, 0x59,
	0x38, 0xe1, 0xb1, 0x45, 0xaf, 0x31, 0xe7, 0x98, 0x86, 0x4a, 0xcc, 0xc4, 0x29, 0xc6, 0xb6, 0xf6,
	0x35, 0x96, 0xbb, 0xcb, 0x9d, 0xa9, 0xfd, 0xcf, 0xce, 0xbc, 0x82, 0xaa, 0x5f, 0x40, 0xf3, 0x85,
	0x42, 0xf9, 0x44, 0x62, 0xac, 0x48, 0x17, 0xd6, 0x66, 0x0a, 0x65, 0x12, 0x4e, 0xd1, 0xd7, 0x3b,
	0xf7, 0xcd, 0x37, 0xc3, 0xf6, 0x8d, 0x90, 0xae, 0x8a, 0x26, 0x9b, 0xfb, 0x64, 0x03, 0x6a, 0x87,
	0xcf, 0xf6, 0xfc, 0x60, 0x8c, 0x49, 0xbf, 0x80, 0xcd, 0xcf, 0xf6, 0x66, 0x7a, 0xfc, 0x64, 0xc2,
	0x31, 0xd1, 0x47, 0x18, 0x49, 0xd4, 0x2e, 0xc7, 0x06, 0xd4, 0x4e, 0xf1, 0xcc, 0xd3, 0x1b, 0x93,
	0x6c, 0x42, 0x43, 0x59, 0x80, 0xe7, 0xf5, 0x9e, 0x3d, 0x8f, 0x44, 0x8a, 0xaa, 0x53, 0xdb, 0xaa,
	0xd9, 0x73, 0xeb, 0xd1, 0x07, 0xd0, 0x76, 0xdc, 0x22, 0x46, 0xc7, 0x49, 0xa0, 0x1e, 0x89, 0x38,
	0xbf, 0xb3, 0xb5, 0xe9, 0x0f, 0x55, 0x68, 0x19, 0x54, 0x3e, 0xc8, 0xc7, 0xd0, 0x9c, 0xe5, 0x85,
	0x5a, 0x60, 0x69, 0x9f, 0xe6, 0xbd, 0x38, 0xa8, 0xb0, 0x2b, 0x3c, 0x19, 0xc2, 0xa6, 0x08, 0xcb,
	0xca, 0xf1, 0x62, 0xde, 0x2e, 0x32, 0x95, 0x97, 0x7f, 0x50, 0x61, 0x37, 0x30, 0x91, 0xe7, 0xcb,
	0x65, 0x79, 0x39, 0x6c, 0xdd, 0xc4, 0x9d, 0xe3, 0x0e, 0x2a, 0x6c, 0x29, 0x72, 0x7f, 0x15, 0x56,
	0x22, 0x63, 0x3c, 0xaf, 0xaf, 0xd5, 0x37, 0x1e, 0xd1, 0x9f, 0x03, 0x58, 0x77, 0xbd, 0xf0, 0x3a,
	0x35, 0x4f, 0x7c, 0x16, 0x45, 0xa8, 0x94, 0x57, 0x6a, 0xee, 0x92, 0xf7, 0xa0, 0x61, 0x15, 0x96,
	0x57, 0xd6, 0x29, 0xd1, 0x92, 0xfd, 0xce, 0x3c, 0x8e, 0x7c, 0x02, 0xad, 0xc3, 0x67, 0x7b, 0x39,
	0xb5, 0xbf, 0xf4, 0xdb, 0xc5, 0xb0, 0x6b, 0x20, 0x76, 0x3d, 0x82, 0x2e, 0x12, 0x98, 0x61, 0xea,
	0xb3, 0x74, 0x3e, 0x4c, 0x63, 0x93, 0xb7, 0xa0, 0x19, 0x8d, 0xc3, 0xc9, 0x04, 0x93, 0x11, 0x7a,
	0x95, 0x5c, 0x1d, 0xd0, 0x0f, 0xa0, 0xcd, 0x9c, 0xa8, 0xf3, 0x61, 0x2f, 0xaf, 0x8c, 0xa0, 0xb8,
	0x32, 0x68, 0x04, 0x77, 0x8e, 0x44, 0xc4, 0xc3, 0x49, 0x1e, 0x64, 0x14, 0x2e, 0x45, 0xc6, 0x63,
	0x94, 0xb9, 0xfa, 0x73, 0x9f, 0x7c, 0x08, 0x4d, 0x1e, 0xa7, 0xc7, 0xff, 0xad, 0x33, 0x57, 0x50,
	0xca, 0xa0, 0xc1, 0xec, 0x5b, 0x27, 0x3d, 0xa8, 0xfa, 0xbd, 0xd0, 0xdc, 0x6f, 0xff, 0xf3, 0xe7,
	0x7d, 0x18, 0x2a, 0x91, 0xec, 0xd2, 0xaf, 0x78, 0x4c, 0x59, 0x95, 0xdb, 0x37, 0xf4, 0x52, 0x73,
	0x5f, 0x9c, 0x31, 0x8d, 0xfe, 0x25, 0x86, 0x4a, 0xe4, 0x1b, 0xcf, 0x7b, 0x74, 0x15, 0x56, 0x9e,
	0x4e, 0x53, 0x7d, 0xf6, 0xf0, 0xfb, 0x3a, 0x80, 0x19, 0xeb, 0x11, 0x66, 0x3c, 0x42, 0x92, 0x41,
	0x2b, 0xbb, 0xda, 0x49, 0xe4, 0x41, 0xf1, 0x7e, 0xc5, 0xfd, 0xd6, 0x7d, 0xe7, 0x16, 0x94, 0x9f,
	0x51, 0xf7, 0xbb, 0x3f, 0xfe, 0xfe, 0xb1, 0x7a, 0x8f, 0xbe, 0x36, 0xc8, 0xde, 0x1f, 0x18, 0xfd,
	0x0e, 0x5c, 0xaa, 0xdd, 0x60, 0x87, 0x8c, 0x61, 0xdd, 0x9c, 0x60, 0xa2, 0x79, 0x14, 0x6a, 0x24,
	0x25, 0xb3, 0xbf, 0xf6, 0x10, 0xbb, 0xbd, 0x9b, 0x3e, 0xfb, 0x54, 0x6f, 0xd8, 0x54, 0x77, 0x69,
	0x7b, 0x9e, 0x6a, 0x22, 0x46, 0x3c, 0x31, 0x99, 0x0e, 0xcd, 0x22, 0xb5, 0x23, 0x24, 0x25, 0xaf,
	0x62, 0x51, 0x03, 0xb7, 0xe6, 0xa9, 0x90, 0x97, 0xd0, 0x52, 0x56, 0x01, 0x9f, 0x9a, 0x04, 0xe4,
	0x7e, 0x31, 0x60, 0x41, 0x20, 0xb7, 0x32, 0x16, 0x9b, 0xe4, 0xe8, 0xcd, 0xd5, 0xbf, 0x84, 0x96,
	0x5b, 0xfa, 0x6e, 0x38, 0x9d, 0xb2, 0xeb, 0x9b, 0xcf, 0xdd, 0xd7, 0x8b, 0x5f, 0xec, 0xb4, 0x4b,
	0xd8, 0x1d, 0xe1, 0x6e, 0xb0, 0xb3, 0xdf, 0x39, 0xbf, 0xe8, 0x05, 0xbf, 0x5f, 0xf4, 0x82, 0xbf,
	0x2e, 0x7a, 0xc1, 0x4f, 0x97, 0xbd, 0xca, 0x2f, 0x97, 0xbd, 0xe0, 0xfc, 0xb2, 0x17, 0x0c, 0x1b,
	0xf6, 0x07, 0xff, 0xe8, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x18, 0x4b, 0x78, 0xa1, 0x6c, 0x08,
	0x00, 0x00,
}
